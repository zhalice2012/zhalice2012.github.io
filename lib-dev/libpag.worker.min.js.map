{"version":3,"file":"libpag.worker.min.js","sources":["../src/worker/events.ts","../src/worker/utils.ts","../src/utils/video-listener.ts","../src/utils/ua.ts","../src/pag-module.ts","../src/core/bitmap-image.ts","../src/worker/video-reader.ts","../src/utils/type-utils.ts","../src/core/video-reader.ts","../src/constant.ts","../src/utils/common.ts","../src/utils/decorators.ts","../src/worker/pag-file.ts","../src/utils/canvas.ts","../src/worker/pag-view.ts","../src/worker/pag-image.ts","../src/worker/client.ts"],"sourcesContent":["export enum WorkerMessageType {\n  PAGInit = 'PAGInit',\n  // PAGView static methods\n  PAGView_init = 'PAGView.init',\n  // PAGView instance methods\n  PAGView_duration = 'PAGView.duration',\n  PAGView_play = 'PAGView.play',\n  PAGView_pause = 'PAGView.pause',\n  PAGView_stop = 'PAGView.stop',\n  PAGView_setRepeatCount = 'PAGView.setRepeatCount',\n  PAGView_getProgress = 'PAGView.getProgress',\n  PAGView_currentFrame = 'PAGView.currentFrame',\n  PAGView_setProgress = 'PAGView.setProgress',\n  PAGView_scaleMode = 'PAGView.scaleMode',\n  PAGView_setScaleMode = 'PAGView.setScaleMode',\n  PAGView_flush = 'PAGView.flush',\n  PAGView_getDebugData = 'PAGView.getDebugData',\n  PAGView_destroy = 'PAGView.destroy',\n  // PAGFile static methods\n  PAGFile_load = 'PAGFile.load',\n  // PAGFile instance methods\n  PAGFile_getTextData = 'PAGFile.getTextData',\n  PAGFile_replaceText = 'PAGFile.replaceText',\n  PAGFile_replaceImage = 'PAGFile.replaceImage',\n  PAGFile_destroy = 'PAGFile.destroy',\n  // PAGImage static methods\n  PAGImage_fromSource = 'PAGImage.fromSource',\n  PAGImage_destroy = 'PAGImage.destroy',\n  // VideoReader static methods\n  VideoReader_constructor = 'VideoReader.constructor',\n  // VideoReader instance methods\n  VideoReader_prepare = 'VideoReader.prepare',\n  VideoReader_play = 'VideoReader.play',\n  VideoReader_pause = 'VideoReader.pause',\n  VideoReader_stop = 'VideoReader.stop',\n  VideoReader_getError = 'VideoReader.getError',\n  // Binding video reader\n  PAGModule_linkVideoReader = 'PAGModule.linkVideoReader',\n  // TextDocument instance methods\n  TextDocument_delete = 'TextDocument.delete',\n}\n","import type { WorkerMessage } from './worker';\n\nlet messageCount = 0;\nconst generateMessageName = (name: string) => `${name}_${messageCount++}`;\n\nexport interface WorkerInterface {\n  postMessage: (message: any, transfer: Transferable[]) => void;\n  addEventListener: (type: string, listener: (event: MessageEvent) => void) => void;\n  removeEventListener: (type: string, listener: (event: MessageEvent) => void) => void;\n}\n\nexport const postMessage = <T>(\n  worker: WorkerInterface,\n  message: WorkerMessage,\n  callback: (...args: any[]) => T,\n  transfer: (OffscreenCanvas | Transferable)[] = [],\n): Promise<T> => {\n  return new Promise((resolve) => {\n    const name = generateMessageName(message.name);\n    const handle = (event: MessageEvent<WorkerMessage>) => {\n      if (event.data.name === name) {\n        worker.removeEventListener('message', handle);\n        resolve(callback(...event.data.args));\n      }\n    };\n    worker.addEventListener('message', handle);\n    worker.postMessage({ name, args: message.args }, transfer);\n  });\n};\n","type K = keyof HTMLVideoElementEventMap;\n\nlet eventHandlers: {\n  [key in K]?: {\n    node: HTMLVideoElement;\n    handler: (this: HTMLVideoElement, ev: HTMLVideoElementEventMap[K]) => any;\n    capture: boolean;\n  }[];\n} = {};\n\nexport const addListener = (\n  node: HTMLVideoElement,\n  event: K,\n  handler: (this: HTMLVideoElement, ev: HTMLVideoElementEventMap[K]) => any,\n  capture = false,\n) => {\n  if (!(event in eventHandlers)) {\n    eventHandlers[event] = [];\n  }\n  eventHandlers[event]?.push({ node: node, handler: handler, capture: capture });\n  node.addEventListener(event, handler, capture);\n};\n\nexport const removeListener = (\n  targetNode: HTMLElement,\n  event: K,\n  targetHandler: (this: HTMLVideoElement, ev: HTMLVideoElementEventMap[K]) => any,\n) => {\n  if (!(event in eventHandlers)) return;\n  eventHandlers[event]\n    ?.filter(({ node, handler }) => node === targetNode && handler === targetHandler)\n    .forEach(({ node, handler, capture }) => node.removeEventListener(event, handler, capture));\n};\n\nexport const removeAllListeners = (targetNode: HTMLElement, event: K) => {\n  if (!(event in eventHandlers)) return;\n  eventHandlers[event]\n    ?.filter(({ node }) => node === targetNode)\n    .forEach(({ node, handler, capture }) => node.removeEventListener(event, handler, capture));\n\n  eventHandlers[event] = eventHandlers[event]?.filter(({ node }) => node !== targetNode);\n};\n","const nav = navigator?.userAgent || '';\nexport const ANDROID = /android|adr/i.test(nav);\nexport const MOBILE = /(mobile)/i.test(nav) && ANDROID;\nexport const MACOS = !(/(mobile)/i.test(nav) || MOBILE) && /Mac OS X/i.test(nav);\nexport const IPHONE = /(iphone|ipad|ipod)/i.test(nav);\nexport const WECHAT = /MicroMessenger/i.test(nav);\nexport const SAFARI_OR_IOS_WEBVIEW =  /^((?!chrome|android).)*safari/i.test(nav) || IPHONE;\nexport const WORKER = typeof globalThis.importScripts === 'function';\n","import type { PAG } from './types';\n\nexport let PAGModule: PAG;\n\nexport const setPAGModule = (module: PAG) => {\n  PAGModule = module;\n};\n\nexport const getPAGModule = () => PAGModule;\n","export class BitmapImage {\n  public bitmap: ImageBitmap | null;\n\n  public constructor(bitmap: ImageBitmap | null) {\n    this.bitmap = bitmap;\n  }\n\n  public setBitmap(bitmap: ImageBitmap) {\n    if (this.bitmap) {\n      this.bitmap.close();\n    }\n    this.bitmap = bitmap;\n  }\n}\n","import { WorkerMessageType } from './events';\nimport { postMessage } from './utils';\n\nimport type { EmscriptenGL } from '../types';\nimport { BitmapImage } from '../core/bitmap-image';\n\nexport class WorkerVideoReader {\n  public bitmap: ImageBitmap | null = null;\n  public isSought = false;\n  public isPlaying = false;\n\n  private proxyId: number;\n  private bitmapImage: BitmapImage = new BitmapImage(null);\n\n  public constructor(proxyId: number) {\n    this.proxyId = proxyId;\n  }\n\n  public prepare(targetFrame: number, playbackRate: number) {\n    return new Promise<void>((resolve) => {\n      postMessage(\n        self,\n        { name: WorkerMessageType.VideoReader_prepare, args: [this.proxyId, targetFrame, playbackRate] },\n        (res) => {\n          this.bitmapImage.setBitmap(res);\n          resolve();\n        },\n      );\n    });\n  }\n\n  public getVideo() {\n    return this.bitmapImage;\n  }\n\n  public onDestroy() {\n    self.postMessage({ name: 'VideoReader.onDestroy', args: [this.proxyId] });\n  }\n\n  public play() {\n    return new Promise<void>((resolve) => {\n      postMessage(self, { name: WorkerMessageType.VideoReader_play, args: [this.proxyId] }, () => {\n        resolve();\n      });\n    });\n  }\n\n  public pause() {\n    postMessage(self, { name: WorkerMessageType.VideoReader_pause, args: [this.proxyId] }, () => {});\n  }\n\n  public stop() {\n    postMessage(self, { name: WorkerMessageType.VideoReader_stop, args: [this.proxyId] }, () => {});\n  }\n\n  public getError() {\n    return new Promise<any>((resolve) => {\n      postMessage(self, { name: WorkerMessageType.VideoReader_getError, args: [this.proxyId] }, (res) => {\n        resolve(res);\n      });\n    });\n  }\n}\n","import { PAGModule } from '../pag-module';\nimport { LayerType, Vector } from '../types';\n\nimport type { PAGLayer } from '../pag-layer';\nimport type { PAGImageLayer } from '../pag-image-layer';\nimport type { PAGSolidLayer } from '../pag-solid-layer';\nimport type { PAGTextLayer } from '../pag-text-layer';\n\nconst rewindData = (fn: (...args: any[]) => any, scope: any, ...args: any[]) => {\n  if (PAGModule.Asyncify.currData !== null) {\n    const currData = PAGModule.Asyncify.currData;\n    PAGModule.Asyncify.currData = null;\n    const ret = fn.call(scope, ...args);\n    PAGModule.Asyncify.currData = currData;\n    return ret;\n  } else {\n    return fn.call(scope, ...args);\n  }\n};\n\nexport const proxyVector = <T extends (...args: any) => any>(\n  vector: Vector<any>,\n  process: T,\n): Vector<ReturnType<T>> => {\n  const proxy = new Proxy(vector, {\n    get(target, property, receiver) {\n      switch (property) {\n        case 'get':\n          return (index: number) => {\n            const wasmIns = rewindData(target.get, target, index);\n            return !wasmIns ? wasmIns : process(wasmIns);\n          };\n        case 'push_back':\n          return (value: ReturnType<T>) => {\n            rewindData(target.push_back, target, value.wasmIns || value);\n            return undefined;\n          };\n        case 'size':\n          return () => {\n            return rewindData(target.size, target);\n          };\n        default:\n          return Reflect.get(target, property, receiver);\n      }\n    },\n  });\n  return proxy;\n};\n\nexport const layer2typeLayer = (wasmIns: any): PAGSolidLayer | PAGTextLayer | PAGImageLayer | PAGLayer => {\n  switch (rewindData(wasmIns._layerType, wasmIns)) {\n    case LayerType.Solid:\n      return new PAGModule.PAGSolidLayer(wasmIns);\n    case LayerType.Text:\n      return new PAGModule.PAGTextLayer(wasmIns);\n    case LayerType.Image:\n      return new PAGModule.PAGImageLayer(wasmIns);\n    default:\n      return new PAGModule.PAGLayer(wasmIns);\n  }\n};\n\nexport const getLayerTypeName = (layerType: LayerType) => {\n  switch (layerType) {\n    case LayerType.Solid:\n      return 'Solid';\n    case LayerType.Text:\n      return 'Text';\n    case LayerType.Shape:\n      return 'Shape';\n    case LayerType.Image:\n      return 'Image';\n    case LayerType.PreCompose:\n      return 'PreCompose';\n    default:\n      return 'Unknown';\n  }\n};\n\nexport const getWasmIns = (value: any) => {\n  if (value?.wasmIns) {\n    return value.wasmIns;\n  }\n  return value;\n};\n\nexport const isInstanceOf = (value: any, type: any) => typeof type !== 'undefined' && value instanceof type;\n","import {\n  VIDEO_DECODE_WAIT_FRAME,\n  VIDEO_DECODE_SEEK_TIMEOUT_FRAME,\n  VIDEO_PLAYBACK_RATE_MAX,\n  VIDEO_PLAYBACK_RATE_MIN,\n} from '../constant';\nimport { addListener, removeListener, removeAllListeners } from '../utils/video-listener';\nimport { IPHONE, WECHAT, SAFARI_OR_IOS_WEBVIEW, WORKER } from '../utils/ua';\nimport { PAGModule } from '../pag-module';\nimport { WorkerMessageType } from '../worker/events';\nimport { WorkerVideoReader } from '../worker/video-reader';\nimport { postMessage } from '../worker/utils';\n\nimport type { TimeRange, VideoReader as VideoReaderInterfaces } from '../interfaces';\nimport type { PAGPlayer } from '../pag-player';\nimport { isInstanceOf } from '../utils/type-utils';\n\nconst UHD_RESOLUTION = 3840;\n\n// Get video initiated token on Wechat browser.\nconst getWechatNetwork = () => {\n  return new Promise<void>((resolve) => {\n    window.WeixinJSBridge.invoke(\n      'getNetworkType',\n      {},\n      () => {\n        resolve();\n      },\n      () => {\n        resolve();\n      },\n    );\n  });\n};\n\nconst waitVideoCanPlay = (videoElement: HTMLVideoElement) => {\n  return new Promise((resolve) => {\n    const canplayHandle = () => {\n      removeListener(videoElement, 'canplay', canplayHandle);\n      clearTimeout(timer);\n      resolve(true);\n    };\n    addListener(videoElement, 'canplay', canplayHandle);\n    const timer = setTimeout(() => {\n      removeListener(videoElement, 'canplay', canplayHandle);\n      resolve(false);\n    }, 1000);\n  });\n};\n\nexport class VideoReader {\n  public static async create(\n    source: Uint8Array | HTMLVideoElement,\n    width: number,\n    height: number,\n    frameRate: number,\n    staticTimeRanges: TimeRange[],\n  ): Promise<VideoReaderInterfaces> {\n    if (WORKER) {\n      const proxyId = await new Promise<number>((resolve) => {\n        // TODO: source as HTMLVideoElement in WebWorker version.\n        const uint8Array = source as Uint8Array;\n        const buffer = uint8Array.buffer.slice(uint8Array.byteOffset, uint8Array.byteOffset + uint8Array.byteLength);\n        postMessage(\n          self,\n          {\n            name: WorkerMessageType.VideoReader_constructor,\n            args: [buffer, width, height, frameRate, staticTimeRanges, true],\n          },\n          (res) => {\n            resolve(res);\n          },\n          [buffer],\n        );\n      });\n      const videoReader = new WorkerVideoReader(proxyId);\n      PAGModule.currentPlayer?.linkVideoReader(videoReader);\n      return videoReader;\n    }\n    return new VideoReader(source, width, height, frameRate, staticTimeRanges);\n  }\n\n  public isSought = false;\n  public isPlaying = false;\n  public bitmap: ImageBitmap | null = null;\n\n  private videoEl: HTMLVideoElement | null = null;\n  private frameRate = 0;\n  private canplay = false;\n  private staticTimeRanges: StaticTimeRanges | null = null;\n  private disablePlaybackRate = false;\n  private error: any = null;\n  private player: PAGPlayer | null = null;\n  private width = 0;\n  private height = 0;\n  private bitmapCanvas: OffscreenCanvas | null = null;\n  private bitmapCtx: OffscreenCanvasRenderingContext2D | null = null;\n\n  public constructor(\n    source: Uint8Array | HTMLVideoElement,\n    width: number,\n    height: number,\n    frameRate: number,\n    staticTimeRanges: TimeRange[],\n    isWorker = false,\n  ) {\n    if (isInstanceOf(source, globalThis.HTMLVideoElement)) {\n      this.videoEl = source as HTMLVideoElement;\n      this.canplay = true;\n    } else {\n      this.videoEl = document.createElement('video');\n      this.videoEl.style.display = 'none';\n      this.videoEl.muted = true;\n      this.videoEl.playsInline = true;\n      this.videoEl.preload = 'auto'; // use load() will make a bug on Chrome.\n      this.videoEl.width = width;\n      this.videoEl.height = height;\n      waitVideoCanPlay(this.videoEl).then(() => {\n        this.canplay = true;\n      });\n      const blob = new Blob([source as Uint8Array], { type: 'video/mp4' });\n      this.videoEl.src = URL.createObjectURL(blob);\n      if (IPHONE) {\n        // use load() will make a bug on Chrome.\n        this.videoEl.load();\n      }\n    }\n    this.frameRate = frameRate;\n    this.width = width;\n    this.height = height;\n    this.staticTimeRanges = new StaticTimeRanges(staticTimeRanges);\n    if (UHD_RESOLUTION < width || UHD_RESOLUTION < height) {\n      this.disablePlaybackRate = true;\n    }\n    if (!isWorker) {\n      this.linkPlayer(PAGModule.currentPlayer);\n    }\n  }\n\n  public async prepare(targetFrame: number, playbackRate: number) {\n    console.log('aaa js -------- prepare: '+ JSON.stringify(targetFrame));\n    this.setError(null); // reset error\n    this.isSought = false; // reset seek status\n    const { currentTime } = this.videoEl!;\n    const targetTime = targetFrame / this.frameRate;\n    if (currentTime === 0 && targetTime === 0) {\n      if (!this.canplay && !SAFARI_OR_IOS_WEBVIEW) {\n        await waitVideoCanPlay(this.videoEl!);\n      } else {\n        try {\n          await this.play();\n        } catch (e) {\n          this.setError(e);\n        }\n        await new Promise<void>((resolve) => {\n          requestAnimationFrame(() => {\n            this.pause();\n            resolve();\n          });\n        });\n      }\n    } else {\n      if (Math.round(targetTime * this.frameRate) === Math.round(currentTime * this.frameRate)) {\n        // Current frame\n      } else if (this.staticTimeRanges?.contains(targetFrame)) {\n        // Static frame\n        console.log('aaa seek 1: targetTime='+ JSON.stringify(targetTime), 'currentTime='+ JSON.stringify(currentTime));\n        await this.seek(targetTime, false);\n        return;\n      } else if (Math.abs(currentTime - targetTime) < (1 / this.frameRate) * VIDEO_DECODE_WAIT_FRAME) {\n        // Within tolerable frame rate deviation\n      } else {\n        // Seek and play\n        this.isSought = true;\n        console.log('aaa seek 2: targetTime='+ JSON.stringify(targetTime), 'currentTime='+ JSON.stringify(currentTime));\n        await this.seek(targetTime);\n        return;\n      }\n    }\n\n    const targetPlaybackRate = Math.min(Math.max(playbackRate, VIDEO_PLAYBACK_RATE_MIN), VIDEO_PLAYBACK_RATE_MAX);\n    if (!this.disablePlaybackRate && this.videoEl!.playbackRate !== targetPlaybackRate) {\n      this.videoEl!.playbackRate = targetPlaybackRate;\n    }\n\n    if (this.isPlaying && this.videoEl!.paused) {\n      try {\n        await this.play();\n      } catch (e) {\n        this.setError(e);\n      }\n    }\n  }\n\n  public getVideo() {\n    return this.videoEl;\n  }\n\n  // Only work in web worker version\n  public async generateBitmap() {\n    // Batter than createImageBitmap from video element in benchmark\n    if (!this.bitmapCanvas) {\n      this.bitmapCanvas = new OffscreenCanvas(this.width, this.height);\n      this.bitmapCanvas!.width = this.width;\n      this.bitmapCanvas!.height = this.height;\n      this.bitmapCtx = this.bitmapCanvas.getContext('2d') as OffscreenCanvasRenderingContext2D | null;\n    }\n    this.bitmapCtx?.fillRect(0, 0, this.width, this.height);\n    this.bitmapCtx?.drawImage(this.videoEl as HTMLVideoElement, 0, 0, this.width, this.height);\n    this.bitmap = await createImageBitmap(this.bitmapCanvas);\n    return this.bitmap;\n  }\n\n  public async play() {\n    if (!this.videoEl!.paused) return;\n    if (WECHAT && window.WeixinJSBridge) {\n      await getWechatNetwork();\n    }\n    if (document.visibilityState !== 'visible') {\n      const visibilityHandle = () => {\n        if (document.visibilityState === 'visible') {\n          if (this.videoEl) this.videoEl.play();\n          window.removeEventListener('visibilitychange', visibilityHandle);\n        }\n      };\n      window.addEventListener('visibilitychange', visibilityHandle);\n      throw new Error('The play() request was interrupted because the document was hidden!');\n    }\n    await this.videoEl?.play();\n  }\n\n  public pause() {\n    this.isPlaying = false;\n    if (this.videoEl!.paused) return;\n    this.videoEl?.pause();\n  }\n\n  public stop() {\n    this.isPlaying = false;\n    if (!this.videoEl!.paused) {\n      this.videoEl?.pause();\n    }\n    this.videoEl!.currentTime = 0;\n  }\n\n  public getError() {\n    return this.error;\n  }\n\n  public onDestroy() {\n    if (this.player) {\n      this.player.unlinkVideoReader(this);\n    }\n    removeAllListeners(this.videoEl!, 'playing');\n    removeAllListeners(this.videoEl!, 'timeupdate');\n    this.videoEl = null;\n    this.bitmapCanvas = null;\n    this.bitmapCtx = null;\n  }\n\n  private seek(targetTime: number, play = true) {\n    return new Promise<void>((resolve) => {\n      let isCallback = false;\n      let timer: any = null;\n      const setVideoState = async () => {\n        if (play && this.videoEl!.paused) {\n          try {\n            await this.play();\n          } catch (e) {\n            this.setError(e);\n          }\n        } else if (!play && !this.videoEl!.paused) {\n          this.videoEl?.pause();\n        }\n      };\n      const seekCallback = async () => {\n        if (!this.videoEl) {\n          this.setError(new Error(\"Video element doesn't exist!\"));\n          resolve();\n          return;\n        }\n        removeListener(this.videoEl, 'seeked', seekCallback);\n        await setVideoState();\n        isCallback = true;\n        clearTimeout(timer);\n        timer = null;\n        resolve();\n      };\n      if (!this.videoEl) {\n        this.setError(new Error(\"Video element doesn't exist!\"));\n        resolve();\n        return;\n      }\n      addListener(this.videoEl, 'seeked', seekCallback);\n      this.videoEl!.currentTime = targetTime;\n      // Timeout\n      timer = setTimeout(() => {\n        if (!isCallback) {\n          if (!this.videoEl) {\n            this.setError(new Error(\"Video element doesn't exist!\"));\n            resolve();\n            return;\n          } else {\n            removeListener(this.videoEl, 'seeked', seekCallback);\n            setVideoState();\n            resolve();\n          }\n        }\n      }, (1000 / this.frameRate) * VIDEO_DECODE_SEEK_TIMEOUT_FRAME);\n    });\n  }\n\n  private setError(e: any) {\n    this.error = e;\n  }\n\n  private linkPlayer(player: PAGPlayer | null) {\n    this.player = player;\n    if (player) {\n      player.linkVideoReader(this);\n    }\n  }\n}\n\nexport class StaticTimeRanges {\n  private timeRanges: TimeRange[];\n\n  public constructor(timeRanges: TimeRange[]) {\n    this.timeRanges = timeRanges;\n  }\n\n  public contains(targetFrame: number) {\n    if (this.timeRanges.length === 0) return false;\n    for (let timeRange of this.timeRanges) {\n      if (timeRange.start <= targetFrame && targetFrame < timeRange.end) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n","/**\n * VideoDecode wait frame num.\n */\nexport const VIDEO_DECODE_WAIT_FRAME = 3;\n/**\n * VideoDecode seek timeout frame num.\n */\nexport const VIDEO_DECODE_SEEK_TIMEOUT_FRAME = 12;\n/**\n * NAL unit length. [ 0, 0, 0, 1 ]\n */\nexport const NALU_HEADER_LENGTH = 4;\n/**\n * Web safe font.\n */\nexport const WEB_SAFE_FONT = 'Arial';\n/**\n * Default render canvas size.\n */\nexport const DEFAULT_CANVAS_SIZE = 2560;\n/**\n * Default WebGL ContextAttributes\n */\nexport const WEBGL_CONTEXT_ATTRIBUTES = {\n  depth: false,\n  stencil: false,\n  antialias: false,\n};\n\nexport const VIDEO_PLAYBACK_RATE_MIN = 0.125;\nexport const VIDEO_PLAYBACK_RATE_MAX = 4;\n\nexport const CANVAS_POOL_MAX_SIZE = 10;\n","import { isInstanceOf } from './type-utils';\n\nexport const readFile = (file: File) =>\n  new Promise<ArrayBuffer | null>((resolve) => {\n    const reader = new FileReader();\n    reader.onload = () => {\n      resolve(reader.result as ArrayBuffer | null);\n    };\n    reader.onerror = () => {\n      console.error((reader.error as DOMException).message);\n    };\n    reader.readAsArrayBuffer(file);\n  });\n\nexport const transferToArrayBuffer = (data: File | Blob | ArrayBuffer) => {\n  if (isInstanceOf(data, globalThis.File)) {\n    return readFile(data as File);\n  } else if (isInstanceOf(data, globalThis.Blob)) {\n    return readFile(new File([data as Blob], ''));\n  } else if (isInstanceOf(data, globalThis.ArrayBuffer)) {\n    return Promise.resolve(data as ArrayBuffer);\n  }\n  return Promise.resolve(null);\n};\n\nexport const concatUint8Arrays = (arrays: Array<Uint8Array>) => {\n  let totalLength = 0;\n  for (const arr of arrays) {\n    totalLength += arr.byteLength;\n  }\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const arr of arrays) {\n    result.set(arr, offset);\n    offset += arr.byteLength;\n  }\n  return result;\n};\n","import { PAGModule } from '../pag-module';\n\nexport function wasmAwaitRewind(constructor: any) {\n  const ignoreStaticFunctions = ['length', 'name', 'prototype', 'wasmAsyncMethods'];\n  let staticFunctions = Object.getOwnPropertyNames(constructor).filter(\n    (name) => ignoreStaticFunctions.indexOf(name) === -1,\n  );\n  if (constructor.wasmAsyncMethods && constructor.wasmAsyncMethods.length > 0) {\n    staticFunctions = staticFunctions.filter((name) => constructor.wasmAsyncMethods.indexOf(name) === -1);\n  }\n\n  let functions = Object.getOwnPropertyNames(constructor.prototype).filter(\n    (name) => name !== 'constructor' && typeof constructor.prototype[name] === 'function',\n  );\n  if (constructor.prototype.wasmAsyncMethods && constructor.prototype.wasmAsyncMethods.length > 0) {\n    functions = functions.filter((name) => constructor.prototype.wasmAsyncMethods.indexOf(name) === -1);\n  }\n\n  const proxyFn = (target: { [prop: string]: (...args: any[]) => any }, methodName: string) => {\n    const fn = target[methodName];\n    target[methodName] = function (...args) {\n      if (PAGModule.Asyncify.currData !== null) {\n        const currData = PAGModule.Asyncify.currData;\n        PAGModule.Asyncify.currData = null;\n        const ret = fn.call(this, ...args);\n        PAGModule.Asyncify.currData = currData;\n        return ret;\n      } else {\n        return fn.call(this, ...args);\n      }\n    };\n  };\n\n  staticFunctions.forEach((name) => proxyFn(constructor, name));\n  functions.forEach((name) => proxyFn(constructor.prototype, name));\n}\n\nexport function wasmAsyncMethod(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  if (!target.wasmAsyncMethods) {\n    target.wasmAsyncMethods = [];\n  }\n  target.wasmAsyncMethods.push(propertyKey);\n}\n\nexport function destroyVerify(constructor: any) {\n  let functions = Object.getOwnPropertyNames(constructor.prototype).filter(\n    (name) => name !== 'constructor' && typeof constructor.prototype[name] === 'function',\n  );\n\n  const proxyFn = (target: { [prop: string]: any }, methodName: string) => {\n    const fn = target[methodName];\n    target[methodName] = function (...args: any[]) {\n      if (this['isDestroyed']) {\n        console.error(`Don't call ${methodName} of the ${constructor.name} that is destroyed.`);\n        return;\n      }\n      return fn.call(this, ...args);\n    };\n  };\n  functions.forEach((name) => proxyFn(constructor.prototype, name));\n}\n","import { WorkerMessageType } from './events';\nimport { postMessage } from './utils';\nimport { transferToArrayBuffer } from '../utils/common';\nimport { destroyVerify } from '../utils/decorators';\n\nimport type { WorkerPAGImage } from './pag-image';\nimport type { TextDocument } from '../types';\n\n@destroyVerify\nexport class WorkerPAGFile {\n  /**\n   * Load pag file from file.\n   */\n  public static async load(worker: Worker, data: File | Blob | ArrayBuffer) {\n    const buffer = await transferToArrayBuffer(data);\n    if (!buffer)\n      throw new Error(\n        'Initialize PAGFile data type error, please put check data type must to be File ｜ Blob | ArrayBuffer!',\n      );\n    return await postMessage(\n      worker,\n      { name: WorkerMessageType.PAGFile_load, args: [data] },\n      (key) => new WorkerPAGFile(worker, key),\n    );\n  }\n\n  public key: number;\n  public worker: Worker;\n  public isDestroyed = false;\n\n  public constructor(worker: Worker, key: number) {\n    this.worker = worker;\n    this.key = key;\n  }\n  /**\n   * Get a text data of the specified index. The index ranges from 0 to numTexts - 1.\n   * Note: It always returns the default text data.\n   */\n  public getTextData(editableTextIndex: number) {\n    return postMessage(\n      this.worker,\n      { name: WorkerMessageType.PAGFile_getTextData, args: [this.key, editableTextIndex] },\n      (res: TextDocument & { key: number }) => {\n        res.delete = () => {\n          return postMessage(\n            this.worker,\n            { name: WorkerMessageType.TextDocument_delete, args: [res.key] },\n            () => undefined,\n          );\n        };\n        return res;\n      },\n    );\n  }\n  /**\n   * Replace the text data of the specified index. The index ranges from 0 to PAGFile.numTexts - 1.\n   * Passing in null for the textData parameter will reset it to default text data.\n   */\n  public replaceText(editableTextIndex: number, textData: TextDocument & { [prop: string]: any }): Promise<void> {\n    const textDocument: { [prop: string]: any } = {};\n    for (const key in textData) {\n      if (key !== 'delete') {\n        textDocument[key] = textData[key];\n      }\n    }\n    return postMessage(\n      this.worker,\n      { name: WorkerMessageType.PAGFile_replaceText, args: [this.key, editableTextIndex, textDocument] },\n      () => undefined,\n    );\n  }\n  /**\n   * Replace the image content of the specified index with a PAGImage object. The index ranges from\n   * 0 to PAGFile.numImages - 1. Passing in null for the image parameter will reset it to default\n   * image content.\n   */\n  public replaceImage(editableImageIndex: number, pagImage: WorkerPAGImage) {\n    return postMessage(\n      this.worker,\n      { name: WorkerMessageType.PAGFile_replaceImage, args: [this.key, editableImageIndex, pagImage.key] },\n      () => undefined,\n    );\n  }\n\n  public destroy(): Promise<void> {\n    return postMessage(this.worker, { name: WorkerMessageType.PAGFile_destroy, args: [this.key] }, () => {\n      this.isDestroyed = true;\n    });\n  }\n}\n","import { CANVAS_POOL_MAX_SIZE } from '../constant';\nimport { isInstanceOf } from './type-utils';\nimport { SAFARI_OR_IOS_WEBVIEW, WORKER } from './ua';\n\nconst canvasPool = new Array<HTMLCanvasElement | OffscreenCanvas>();\n\nexport const isOffscreenCanvas = (element: any) => isInstanceOf(element, globalThis.OffscreenCanvas);\n\nexport const isCanvas = (element: any) =>\n  isOffscreenCanvas(element) || isInstanceOf(element, globalThis.HTMLCanvasElement);\n\nexport const getCanvas2D = (width: number, height: number) => {\n  let canvas = canvasPool.pop() || createCanvas2D();\n  if (canvas !== null) {\n    canvas.width = width;\n    canvas.height = height;\n  }\n  return canvas;\n};\n\nexport const releaseCanvas2D = (canvas: HTMLCanvasElement | OffscreenCanvas) => {\n  if (canvasPool.length < CANVAS_POOL_MAX_SIZE) {\n    canvasPool.push(canvas);\n  }\n};\n\nconst createCanvas2D = () => {\n  /**\n   * Safari browser does not support OffscreenCanvas before version 16.4.\n   * After version 16.4, OffscreenCanvas is supported, but type checking errors still exist for WebGL interfaces on OffscreenCanvas.\n   * Therefore, HTMLCanvas Element is used uniformly in Safari.\n   */\n  if (SAFARI_OR_IOS_WEBVIEW && !WORKER) {\n    return document.createElement('canvas');\n  }\n  try {\n    const offscreenCanvas = new OffscreenCanvas(0, 0);\n    const context = offscreenCanvas.getContext('2d') as OffscreenCanvasRenderingContext2D;\n    if (typeof context.measureText === 'function') return offscreenCanvas;\n    return document.createElement('canvas');\n  } catch (err) {\n    return document.createElement('canvas');\n  }\n};\n\nexport const calculateDisplaySize = (canvas: HTMLCanvasElement) => {\n  const styleDeclaration = globalThis.getComputedStyle(canvas, null);\n  const computedSize = {\n    width: Number(styleDeclaration.width.replace('px', '')),\n    height: Number(styleDeclaration.height.replace('px', '')),\n  };\n  if (computedSize.width > 0 && computedSize.height > 0) {\n    return computedSize;\n  } else {\n    const styleSize = {\n      width: Number(canvas.style.width.replace('px', '')),\n      height: Number(canvas.style.height.replace('px', '')),\n    };\n    if (styleSize.width > 0 && styleSize.height > 0) {\n      return styleSize;\n    } else {\n      return {\n        width: canvas.width,\n        height: canvas.height,\n      };\n    }\n  }\n};\n","import { WorkerMessageType } from './events';\nimport { postMessage } from './utils';\nimport { calculateDisplaySize } from '../utils/canvas';\nimport { destroyVerify } from '../utils/decorators';\n\nimport type { WorkerPAGFile } from './pag-file';\nimport type { PAGViewOptions } from '../pag-view';\nimport type { DebugData, PAGScaleMode } from '../types';\n\n@destroyVerify\nexport class WorkerPAGView {\n  /**\n   * Create pag view.\n   * @param file pag file.\n   * @param canvas target render canvas.\n   * @param initOptions pag view options\n   * @returns\n   */\n  public static init(file: WorkerPAGFile, canvas: HTMLCanvasElement, initOptions?: PAGViewOptions) {\n    const options = {\n      ...{\n        useScale: true,\n        useCanvas2D: false,\n        firstFrame: true,\n      },\n      ...initOptions,\n    };\n    if (options.useScale) {\n      resizeCanvas(canvas);\n    }\n    const offscreen = canvas.transferControlToOffscreen();\n    return postMessage(\n      file.worker,\n      { name: WorkerMessageType.PAGView_init, args: [file.key, offscreen, initOptions] },\n      (key: number) => new WorkerPAGView(file.worker, key),\n      [offscreen],\n    );\n  }\n\n  public key: number;\n  public worker: Worker;\n  public isDestroyed = false;\n\n  public constructor(worker: Worker, key: number) {\n    this.worker = worker;\n    this.key = key;\n  }\n  /**\n   * The duration of current composition in microseconds.\n   */\n  public duration() {\n    return postMessage(\n      this.worker,\n      { name: WorkerMessageType.PAGView_duration, args: [this.key] },\n      (res: number) => res,\n    );\n  }\n  /**\n   * Start the animation.\n   */\n  public play() {\n    return postMessage(this.worker, { name: WorkerMessageType.PAGView_play, args: [this.key] }, () => undefined);\n  }\n  /**\n   * Pause the animation.\n   */\n  public pause(): Promise<void> {\n    return postMessage(this.worker, { name: WorkerMessageType.PAGView_pause, args: [this.key] }, () => undefined);\n  }\n  /**\n   * Stop the animation.\n   */\n  public stop(): Promise<void> {\n    return postMessage(this.worker, { name: WorkerMessageType.PAGView_stop, args: [this.key] }, () => undefined);\n  }\n  /**\n   * Set the number of times the animation will repeat. The default is 1, which means the animation\n   * will play only once. 0 means the animation will play infinity times.\n   */\n  public setRepeatCount(repeatCount: number): Promise<void> {\n    return postMessage(\n      this.worker,\n      { name: WorkerMessageType.PAGView_setRepeatCount, args: [this.key, repeatCount] },\n      () => undefined,\n    );\n  }\n  /**\n   * Returns the current progress of play position, the value is from 0.0 to 1.0. It is applied only\n   * when the composition is not null.\n   */\n  public getProgress() {\n    return postMessage(\n      this.worker,\n      { name: WorkerMessageType.PAGView_getProgress, args: [this.key] },\n      (res: number) => res,\n    );\n  }\n  /**\n   * Returns the current frame.\n   */\n  public currentFrame() {\n    return postMessage(\n      this.worker,\n      { name: WorkerMessageType.PAGView_currentFrame, args: [this.key] },\n      (res: number) => res,\n    );\n  }\n  /**\n   * Set the progress of play position, the value is from 0.0 to 1.0.\n   */\n  public setProgress(progress: number) {\n    return postMessage(\n      this.worker,\n      {\n        name: WorkerMessageType.PAGView_setProgress,\n        args: [this.key, progress],\n      },\n      () => undefined,\n    );\n  }\n  /**\n   * Returns the current scale mode.\n   */\n  public scaleMode() {\n    return postMessage(\n      this.worker,\n      { name: WorkerMessageType.PAGView_scaleMode, args: [this.key] },\n      (res: number) => res,\n    );\n  }\n  /**\n   * Specifies the rule of how to scale the pag content to fit the surface size. The matrix\n   * changes when this method is called.\n   */\n  public setScaleMode(value: PAGScaleMode): Promise<void> {\n    return postMessage(\n      this.worker,\n      { name: WorkerMessageType.PAGView_setScaleMode, args: [this.key, value] },\n      () => undefined,\n    );\n  }\n  /**\n   * Call this method to render current position immediately. If the play() method is already\n   * called, there is no need to call it. Returns true if the content has changed.\n   */\n  public flush() {\n    return postMessage(this.worker, { name: WorkerMessageType.PAGView_flush, args: [this.key] }, (res: boolean) => res);\n  }\n\n  public getDebugData() {\n    return postMessage(\n      this.worker,\n      { name: WorkerMessageType.PAGView_getDebugData, args: [this.key] },\n      (res: DebugData) => res,\n    );\n  }\n\n  public destroy() {\n    postMessage(this.worker, { name: WorkerMessageType.PAGView_destroy, args: [this.key] }, () => {\n      this.isDestroyed = true;\n    });\n  }\n}\n\nconst resizeCanvas = (canvas: HTMLCanvasElement) => {\n  const displaySize = calculateDisplaySize(canvas);\n  canvas.style.width = `${displaySize.width}px`;\n  canvas.style.height = `${displaySize.height}px`;\n  canvas.width = displaySize.width * globalThis.devicePixelRatio;\n  canvas.height = displaySize.height * globalThis.devicePixelRatio;\n};\n","import { destroyVerify } from '../utils/decorators';\nimport { isInstanceOf } from '../utils/type-utils';\nimport { WorkerMessageType } from './events';\nimport { postMessage } from './utils';\n\n@destroyVerify\nexport class WorkerPAGImage {\n  public static async fromSource(worker: Worker, source: TexImageSource) {\n    const width = isInstanceOf(source, globalThis.HTMLVideoElement)\n      ? (source as HTMLVideoElement).videoWidth\n      : source.width;\n    const height = isInstanceOf(source, globalThis.HTMLVideoElement)\n      ? (source as HTMLVideoElement).videoHeight\n      : source.height;\n    const canvas = new OffscreenCanvas(width, height);\n    canvas.width = source.width;\n    canvas.height = source.height;\n    const ctx = canvas.getContext('2d') as OffscreenCanvasRenderingContext2D;\n    ctx.drawImage(source as CanvasImageSource, 0, 0, source.width, source.height);\n    const bitmap = await createImageBitmap(canvas);\n    return postMessage(\n      worker,\n      { name: WorkerMessageType.PAGImage_fromSource, args: [bitmap] },\n      (key: number) => new WorkerPAGImage(worker, key),\n      [bitmap],\n    );\n  }\n\n  public worker: Worker;\n  public key: number;\n  public isDestroyed = false;\n\n  public constructor(worker: Worker, key: number) {\n    this.worker = worker;\n    this.key = key;\n  }\n\n  public destroy(): Promise<void> {\n    return postMessage(this.worker, { name: WorkerMessageType.PAGImage_destroy, args: [this.key] }, () => {\n      this.isDestroyed = true;\n    });\n  }\n}\n","import { WorkerMessageType } from './events';\nimport { postMessage } from './utils';\nimport { VideoReader } from '../core/video-reader';\nimport { WorkerPAGFile } from './pag-file';\nimport { WorkerPAGView } from './pag-view';\nimport { WorkerPAGImage } from './pag-image';\n\nimport type { WorkerMessage } from './worker';\nimport type { ModuleOption } from '../pag';\nimport type { TimeRange } from '../interfaces';\n\nexport const MAX_ACTIVE_WORKER_CONTEXTS = 4;\n\nconst videoReaders: VideoReader[] = [];\n\nexport interface PAGWorkerOptions {\n  /**\n   * Link to wasm file and libpag core script.\n   */\n  locateFile?: (file: 'libpag.wasm' | 'libpag.js') => string;\n  /**\n   * Configure for worker.\n   */\n  workerOptions?: WorkerOptions;\n}\n\nexport const createPAGWorker = (pagWorkerOptions: PAGWorkerOptions = {}) => {\n  let scriptUrl = pagWorkerOptions.locateFile ? pagWorkerOptions.locateFile('libpag.js') : 'libpag.js';\n  const option: { fileUrl?: string } & ModuleOption = {};\n  if (pagWorkerOptions.locateFile) {\n    option.fileUrl = pagWorkerOptions.locateFile('libpag.wasm');\n  }\n  const worker = new Worker(scriptUrl, pagWorkerOptions.workerOptions);\n  return postMessage(worker, { name: WorkerMessageType.PAGInit, args: [option] }, () => {\n    addGlobalWorkerListener(worker);\n    return worker;\n  });\n};\n\nconst addGlobalWorkerListener = (worker: Worker) => {\n  const handle = (event: MessageEvent<WorkerMessage>) => {\n    if (event.data.name.includes(WorkerMessageType.VideoReader_constructor)) {\n      const videoReader = new VideoReader(\n        ...(event.data.args as [Uint8Array, number, number, number, TimeRange[], boolean]),\n      );\n      videoReaders.push(videoReader);\n      worker.postMessage({ name: event.data.name, args: [videoReaders.length - 1] });\n      return;\n    }\n    if (event.data.name.includes(WorkerMessageType.VideoReader_prepare)) {\n      const [proxyId, targetFrame, playbackRate] = event.data.args as [number, number, number];\n      videoReaders[proxyId].prepare(targetFrame, playbackRate).then(() => {\n        videoReaders[proxyId].generateBitmap().then((bitmap) => {\n          worker.postMessage({ name: event.data.name, args: [bitmap] }, [bitmap]);\n        });\n      });\n    }\n    if (event.data.name.includes(WorkerMessageType.VideoReader_play)) {\n      videoReaders[event.data.args[0]].play().then((res) => {\n        worker.postMessage({ name: event.data.name, args: [res] });\n      });\n    }\n    if (event.data.name.includes(WorkerMessageType.VideoReader_pause)) {\n      videoReaders[event.data.args[0]].pause();\n    }\n    if (event.data.name.includes(WorkerMessageType.VideoReader_stop)) {\n      videoReaders[event.data.args[0]].stop();\n    }\n    if (event.data.name.includes(WorkerMessageType.VideoReader_getError)) {\n      worker.postMessage({ name: event.data.name, args: [videoReaders[event.data.args[0]].getError()] });\n    }\n  };\n  worker.addEventListener('message', handle);\n};\n\nexport { WorkerPAGFile, WorkerPAGView, WorkerPAGImage };\n"],"names":["WorkerMessageType","messageCount","postMessage","worker","message","callback","transfer","Promise","resolve","name","generateMessageName","handle","event","data","removeEventListener","args","addEventListener","eventHandlers","addListener","node","handler","capture","_a","push","removeListener","targetNode","targetHandler","filter","forEach","removeAllListeners","_b","nav","navigator","userAgent","ANDROID","test","MOBILE","IPHONE","WECHAT","SAFARI_OR_IOS_WEBVIEW","WORKER","globalThis","importScripts","PAGModule","BitmapImage","constructor","bitmap","this","setBitmap","close","WorkerVideoReader","proxyId","isSought","isPlaying","bitmapImage","prepare","targetFrame","playbackRate","self","VideoReader_prepare","res","getVideo","onDestroy","play","VideoReader_play","pause","VideoReader_pause","stop","VideoReader_stop","getError","VideoReader_getError","isInstanceOf","value","type","waitVideoCanPlay","videoElement","canplayHandle","clearTimeout","timer","setTimeout","VideoReader","source","width","height","frameRate","staticTimeRanges","isWorker","videoEl","canplay","disablePlaybackRate","error","player","bitmapCanvas","bitmapCtx","HTMLVideoElement","document","createElement","style","display","muted","playsInline","preload","then","blob","Blob","src","URL","createObjectURL","load","StaticTimeRanges","linkPlayer","currentPlayer","static","uint8Array","buffer","slice","byteOffset","byteLength","VideoReader_constructor","videoReader","linkVideoReader","async","console","log","JSON","stringify","setError","currentTime","targetTime","e","requestAnimationFrame","Math","round","contains","seek","abs","targetPlaybackRate","min","max","paused","OffscreenCanvas","getContext","fillRect","drawImage","createImageBitmap","window","WeixinJSBridge","invoke","visibilityState","visibilityHandle","Error","unlinkVideoReader","isCallback","setVideoState","seekCallback","timeRanges","length","timeRange","start","end","readFile","file","reader","FileReader","onload","result","onerror","readAsArrayBuffer","destroyVerify","functions","Object","getOwnPropertyNames","prototype","proxyFn","target","methodName","fn","call","WorkerPAGFile","key","isDestroyed","File","ArrayBuffer","transferToArrayBuffer","PAGFile_load","getTextData","editableTextIndex","PAGFile_getTextData","delete","TextDocument_delete","replaceText","textData","textDocument","PAGFile_replaceText","replaceImage","editableImageIndex","pagImage","PAGFile_replaceImage","destroy","PAGFile_destroy","exports","__decorateClass","Array","WorkerPAGView","canvas","initOptions","__spreadValues","useScale","useCanvas2D","firstFrame","resizeCanvas","offscreen","transferControlToOffscreen","PAGView_init","duration","PAGView_duration","PAGView_play","PAGView_pause","PAGView_stop","setRepeatCount","repeatCount","PAGView_setRepeatCount","getProgress","PAGView_getProgress","currentFrame","PAGView_currentFrame","setProgress","progress","PAGView_setProgress","scaleMode","PAGView_scaleMode","setScaleMode","PAGView_setScaleMode","flush","PAGView_flush","getDebugData","PAGView_getDebugData","PAGView_destroy","displaySize","styleDeclaration","getComputedStyle","computedSize","Number","replace","styleSize","calculateDisplaySize","devicePixelRatio","WorkerPAGImage","videoWidth","videoHeight","PAGImage_fromSource","PAGImage_destroy","videoReaders","addGlobalWorkerListener","includes","generateBitmap","pagWorkerOptions","scriptUrl","locateFile","option","fileUrl","Worker","workerOptions","PAGInit"],"mappings":"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"}